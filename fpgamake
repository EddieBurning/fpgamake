#!/usr/bin/python

## Copyright (c) 2014 Quanta Research Cambridge, Inc.

## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation
## files (the "Software"), to deal in the Software without
## restriction, including without limitation the rights to use, copy,
## modify, merge, publish, distribute, sublicense, and/or sell copies
## of the Software, and to permit persons to whom the Software is
## furnished to do so, subject to the following conditions:

## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.

## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
## NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
## BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
## ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
## CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
## SOFTWARE.

import os
import sys
import re
import glob
import shutil
import argparse
import subprocess

description='''
Generates Makefiles to synthesize, place, and route verilog.

Each module specified will be synthesized into a separate design
checkpoint.

If a floorplan is provided, each instance of the synthesized modules
will be separately placed and routed and then combined into the top
level design.
'''

argparser = argparse.ArgumentParser(description=description)
argparser.add_argument('vpath', help='Verilog path', nargs='+')
argparser.add_argument('-o', '--output', help='Output make file', default='synth.mk')
argparser.add_argument('-s', '--synth', help='Module to synthesize separately', default=[], action='append')
argparser.add_argument('--xci', help='XCI file to use', default=[], action='append')
argparser.add_argument('--xdc', help='XDC file to use', default=[], action='append')
argparser.add_argument('--floorplan', help='Floorplan XDC.', default=None)
argparser.add_argument('-t', '--top', help='Top verilog file')
argparser.add_argument('-b', '--bitfile', help='Bit file to generate', default=None)
argparser.add_argument('--cachedir', help='Cache directory', default='Cache')
argparser.add_argument('-v', '--verbose', help='Verbose operation', default=False)

module_instances={}
modules_used={}
modules_visited={}
verilog_used={}
xdc_files={}

parameterizedModuleRe = r'^\s+(\w+)\s*#'
plainModuleRe = r'^\s+(\w+)\s*(\w+)\('

def find_in_path(fname, path, suffix='.v'):
    if not fname.endswith(suffix):
        fname = fname + suffix
    for p in path:
        if os.path.exists(os.path.join(p, fname)):
            return os.path.join(p, fname)
    return None

def scan_module(module, parent_partition=None, parent_module=None):
    if options.verbose:
        print 'scanning module %s ====================' % module
    vpath = find_in_path(module, options.vpath, '.v')
    modules_visited[module] = vpath
    if not parent_partition:
        parent_partition = module
    submodules=[]
    if not vpath or not os.path.exists(vpath):
        return
    for line in open(vpath):
        m = re.match(plainModuleRe, line)
        m2 = re.match(parameterizedModuleRe, line)
        if m:
            #print 'found block', m.group(1), m.group(2)
            submodule=m.group(1)
            submodules.append(submodule)
            inst=m.group(2)
            if submodule in options.synth:
                if options.verbose:
                    print 'separate synth', submodule, inst
                if module_instances.has_key(submodule):
                    module_instances[submodule].append(inst)
                else:
                    module_instances[submodule] = [inst]
                if modules_used.has_key(parent_partition):
                    modules_used[parent_partition].append(submodule)
                else:
                    modules_used[parent_partition] = [submodule]
            else:
                submodulepath=find_in_path(submodule, options.vpath, '.v')
                if submodulepath and os.path.exists(submodulepath):
                    if verilog_used.has_key(parent_partition):
                        verilog_used[parent_partition].append(submodule)
                    else:
                        verilog_used[parent_partition] = [submodule]
        elif m2:
            submodule = m2.group(1)
            submodules.append(submodule)
            submodulepath=os.path.join('verilog', '%s.v' % submodule)
            if os.path.exists(submodulepath):
                if verilog_used.has_key(parent_partition):
                    verilog_used[parent_partition].append(submodule)
                else:
                    verilog_used[parent_partition] = [submodule]
    for submodule in set(submodules):
        if submodule in modules_visited:
            continue
        if options.verbose:
            print 'scanning submodule: ', set(submodules), ' parent ', parent_partition, parent_module
        scan_module(submodule, parent_partition, module)

def process_modules():
    for module in module_instances:
        vfile = '%s.v' % module
        vpath = find_in_path(module, options.vpath, '.v')
        synthdir = os.path.join('Synth', module)
        if not os.path.isdir(synthdir):
            os.makedirs(synthdir)
        shutil.copyfile(vpath, os.path.join(synthdir, vfile))

        stubpath = 'Synth/stubs/%s-stub.v' % module
        make_stub(vpath, stubpath)

def make_stub(vpath, stubpath):
    stubdir = os.path.dirname(stubpath)
    if not os.path.isdir(stubdir):
        os.makedirs(stubdir)
    f = open(stubpath, 'w')
    for line in open(vpath):
        m = re.match('^\s*module ', line)
        if m:
            f.write("(*black_box*)")
        f.write(line)
    f.close()

makefileHeaderTemplate='''
V=0
ifeq ($(V),0)
  Q=@
else
  Q=
endif

TCLDIR=%(fpgamakedir)s/tcl
CACHEDIR = %(cachedir)s

FLOORPLAN=%(floorplan)s
ifneq ("$(FLOORPLAN)","")
POST_ROUTE_DCP=Impl/top/top-post-route.dcp
endif
SYNTH_NETLISTS=

define SYNTH_RULE
SYNTH_NETLISTS+= Synth/$1/$1-synth.dcp
Synth/$1/$1-synth.dcp: $2
	$(Q)$(eval MODULE=$1)
	@echo FPGAMAKE $(MODULE) synth check
	$(Q)mkdir -p Synth/$(MODULE)
	$(Q)test -f $($(MODULE)_MD5SUM)  && md5sum --quiet -c $($(MODULE)_MD5SUM) && rsync --quiet -av --delete $($(MODULE)_CACHEDIR)/* Synth/$(MODULE)/ || \\
	MODULE=$(MODULE) \\
	VFILES="$($(MODULE)_VFILES) $($(MODULE)_STUBS)" \\
	IP="$($(MODULE)_IP)" \\
	SUBINST="$($(MODULE)_SUBINST)" \\
	vivado -notrace -mode batch -source $(TCLDIR)/synth.tcl
	$(Q)mkdir -p $($(MODULE)_CACHEDIR)
	$(Q)md5sum $($(MODULE)_VFILES) > Synth/$(MODULE)/$(MODULE)-source.md5sum
	$(Q)rsync --quiet -av --delete Synth/$(MODULE)/* $($(MODULE)_CACHEDIR)
endef

define IMPL_RULE
Impl/$1/$1-post-route.dcp: Synth/$2/$2-synth.dcp $3 Impl/oocxdc.timestamp
	$(Q)$(eval MODULE=$2)
	$(Q)$(eval INST=$1)
	@echo FPGAMAKE $(INST) post-place check
	$(Q)MODULE=$(MODULE) INST=$(INST) \\
	XDC="$($(INST)_XDC) $($(INST)_OOCXDC)" \\
	MODULE_NETLISTS="$($(INST)_NETLISTS)" \\
	BITFILE=$($(INST)_BITFILE) \\
	vivado -notrace -mode batch -source $(TCLDIR)/impl.tcl
endef

define TOP_RULE
Impl/TopDown/$1-post-place.dcp: $(FLOORPLAN) $3 Synth/$2/$2-synth.dcp
	$(Q)$(eval MODULE=$2)
	$(Q)$(eval INST=$1)
	@echo FPGAMAKE $(INST) topdown check
	$(Q)mkdir -p Impl/TopDown/
	$(Q)test -f $(TopDown_MD5SUM) && test -f $(TopDown_CACHEDIR)/mkTop.bit && md5sum --quiet -c $(TopDown_MD5SUM) && rsync --quiet -av --delete $(TopDown_CACHEDIR)/* Impl/TopDown/ || \\
	MODULE=$(MODULE) INST=$(INST) \\
	SUBINST="$(TopDown_SUBINST)" \\
	MODULE_NETLISTS="$(TopDown_NETLISTS)" \\
	XDC="$(TopDown_XDC)" \\
	FLOORPLAN="$(FLOORPLAN)" \\
	BITFILE=Impl/TopDown/mkTop.bit \\
	vivado -notrace -mode batch -source $(TCLDIR)/topdown.tcl
	$(Q)mkdir -p $($(INST)_CACHEDIR)
	$(Q)md5sum Synth/$(MODULE)/$(MODULE)-synth.dcp $(TopDown_NETLISTS) $(TopDown_XDC) $(FLOORPLAN) > Impl/TopDown/TopDown-source.md5sum
	$(Q)rsync --quiet -av --delete Impl/TopDown/* $(TopDown_CACHEDIR)/
endef

all: everything

'''

makefileTrailerTemplate='''
everything: $(SYNTH_NETLISTS) Impl/TopDown/top-post-place.dcp $(POST_ROUTE_DCP) %(bitfile)s

'''

synth_template='''
%(module)s_CACHEDIR = $(CACHEDIR)/%(module)s
%(module)s_VFILES = %(vfiles)s
%(module)s_STUBS = %(module_stubs)s
%(module)s_IP = %(xcifiles)s
%(module)s_SUBINST = %(subinst)s
%(module)s_MD5SUM = $(%(module)s_CACHEDIR)/%(module)s-source.md5sum

$(eval $(call SYNTH_RULE,%(module)s,%(module_path)s))
'''
#parameters = AWK BAT CAT DOG
#$(foreach P,$(parameters),$(eval $(call COPY_TO_DEST,$P)))

impl_template='''
%(inst)s_CACHEDIR = $(CACHEDIR)/%(inst)s
%(inst)s_MD5SUM = $(%(inst)s_CACHEDIR)/%(inst)s-source.md5sum
%(inst)s_XDC = %(xdc_files)s
%(inst)s_OOCXDC = %(oocxdc)s
%(inst)s_NETLISTS = "%(module_routed_netlists)s"
%(inst)s_BITFILE = %(bitfile)s

$(eval $(call IMPL_RULE,%(inst)s,%(module)s,%(module_routed_netlists)s))
'''

topdown_template='''
TopDown_CACHEDIR = $(CACHEDIR)/TopDown
TopDown_MD5SUM = $(TopDown_CACHEDIR)/TopDown-source.md5sum
TopDown_XDC = %(xdc_files)s
TopDown_NETLISTS = %(module_synth_netlists)s
TopDown_SUBINST = %(subinst)s

$(eval $(call TOP_RULE,%(inst)s,%(module)s,%(module_synth_netlists)s))

%(bitfile)s: Impl/TopDown/%(inst)s-post-place.dcp
	$(Q)cp -v Impl/TopDown/mkTop.bit %(bitbase)s.bit
	$(Q)cp -v Impl/TopDown/mkTop.bin %(bitbase)s.bin

Impl/oocxdc.timestamp: Impl/TopDown/%(inst)s-post-place.dcp
	MODULE=%(module)s \\
	INST=%(inst)s \\
	SUBINST="%(subinst)s" \\
	vivado -notrace -mode batch -source $(TCLDIR)/write-ooc-xdc.tcl
	touch Impl/oocxdc.timestamp
'''

def write_makefile():
    f = open(options.output, 'w')
    f.write(makefileHeaderTemplate % { 'floorplan': os.path.abspath(options.floorplan) if options.floorplan else '',
                                       'fpgamakedir': fpgamakedir,
                                       'cachedir': os.path.abspath(options.cachedir)
                                       })
    for module in module_instances:
        subinst = []
        module_stubs = []
        if options.top in modules_used:
            subinst = ([' '.join(module_instances[submodule]) for submodule in set(modules_used[options.top])])
        if module in modules_used:
            module_stubs = ['Synth/stubs/%s-stub.v' % (m) for m in set(modules_used[module])]
        f.write(synth_template % { 'module': module,
                                   'module_path': find_in_path(module, options.vpath, '.v'),
                                   'vfiles': ' '.join([find_in_path(module, options.vpath, '.v')] + [find_in_path(vfile, options.vpath, '.v') for vfile in set(verilog_used[module])]) if module in verilog_used else '',
                                   'subinst': ' '.join(subinst),
                                   'module_stubs': ' '.join(module_stubs),
                                   'xcifiles': ' '.join(options.xci),
                                   })
        for inst in set(module_instances[module]):
            subinst_routed_netlists = []
            if module in modules_used:
                for submodule in set(modules_used[module]):
                    if options.verbose:
                        print 'inst', inst, 'submodule', submodule
                    for subinst in module_instances[submodule]:
                        if options.verbose:
                            print '\t', subinst
                        subinst_routed_netlists.append('Impl/%s/%s-post-route.dcp' % (subinst, subinst))


            f.write(impl_template % { 'module': module,
                                      'inst': inst,
                                      'xdc_files': ' '.join([os.path.abspath(xdc) for xdc in xdc_files[inst]]) if inst in xdc_files else '',
                                      'module_routed_netlists': ' '.join(subinst_routed_netlists),
                                      'oocxdc': 'Impl/%(inst)s/%(inst)s-ooc.xdc Impl/%(inst)s/%(inst)s-ooc-clocks.xdc Impl/%(inst)s/%(inst)s-ooc-budget.xdc' % {'inst': inst} if inst != 'top' else '',
                                      'bitfile': options.bitfile if (inst == 'top' and options.bitfile) else '',
                                      })

    submodule_synth_netlists = []
    if options.top in modules_used:
        for submodule in modules_used[options.top]:
            submodule_synth_netlists.append('Synth/%s/%s-synth.dcp' % (submodule, submodule))

    inst = 'top'
    topdown_xdc_files = (' '.join([os.path.abspath(xdc) for xdc in xdc_files[inst]]) if (inst in xdc_files) else '')

    submodules = []
    if options.top in modules_used:
        submodules = set(modules_used[options.top])
    f.write(topdown_template % { 'module': options.top,
                                 'inst': inst,
                                 'subinst': ' '.join([' '.join(module_instances[submodule]) for submodule in submodules]),
                                 'oocxdc': ' '.join([' '.join(['Impl/%(inst)s/%(inst)s-ooc-clocks.xdc Impl/%(inst)s/%(inst)s-ooc.xdc'
                                                               % {'inst': inst}
                                                               for inst in module_instances[submodule]])
                                                     for submodule in submodules]),
                                 'xdc_files': topdown_xdc_files,
                                 'floorplan': os.path.abspath(options.floorplan) if options.floorplan else '',
                                 'module_synth_netlists': ' '.join(submodule_synth_netlists),
                                 'bitfile': options.bitfile if options.bitfile else '',
                                 'bitbase': os.path.splitext(options.bitfile)[0],
            })
    #f.write('\nSYNTH_NETLISTS=%s\n' % ' \\\n\t'.join(['Synth/%s/%s-synth.dcp' % (module, module) for module in module_instances]))
    f.write(makefileTrailerTemplate % { 'bitfile': options.bitfile, })
    f.close()

if __name__=='__main__':
    exename = os.path.abspath(sys.argv[0])
    fpgamakedir = os.path.dirname(exename)
    options = argparser.parse_args()
    module_instances[options.top] = ['top']
    scan_module(options.top)
    for m in options.synth:
        scan_module(m)
    if options.verbose:
        print module_instances
        print modules_used

    xdc_files['top'] = options.xdc
    process_modules()
    write_makefile()
